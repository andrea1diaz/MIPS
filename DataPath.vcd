$date
	Sun Nov 25 20:36:58 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module DataPath $end
$var wire 1 ! RegistroDeestino $end
$var wire 1 " and_u_unico $end
$var wire 8 # pc_increment [7:0] $end
$var wire 32 $ pc_result_4 [31:0] $end
$var wire 5 % readRegister1 [4:0] $end
$var wire 5 & readRegister2 [4:0] $end
$var wire 32 ' shift_join [31:0] $end
$var wire 32 ( target_pc [31:0] $end
$var wire 28 ) shift_out [27:0] $end
$var wire 32 * shift_2 [31:0] $end
$var wire 32 + readDataMemory [31:0] $end
$var wire 32 , readData2 [31:0] $end
$var wire 32 - readData1 [31:0] $end
$var wire 32 . pc_result_shift [31:0] $end
$var wire 32 / pc_result_jump [31:0] $end
$var wire 8 0 pc [7:0] $end
$var wire 5 1 mux_5_result [4:0] $end
$var wire 32 2 mux_32_result [31:0] $end
$var wire 32 3 instruction [31:0] $end
$var wire 32 4 extend_32 [31:0] $end
$var wire 1 5 branch_res $end
$var wire 1 6 and_unico $end
$var wire 1 7 RegistroDestino $end
$var wire 1 8 RegisterWrite $end
$var wire 1 9 MemoryWrite $end
$var wire 1 : MemoryToRegister $end
$var wire 1 ; MemoryRead $end
$var wire 1 < Jump $end
$var wire 1 = Branch $end
$var wire 1 > ALUSrc $end
$var wire 32 ? ALUResult [31:0] $end
$var wire 2 @ ALUOpcode [1:0] $end
$var wire 4 A ALUControl [3:0] $end
$var reg 1 B clk $end
$var reg 16 C op_15_0 [15:0] $end
$var reg 5 D op_15_11 [4:0] $end
$var reg 5 E op_20_16 [4:0] $end
$var reg 26 F op_25_0 [25:0] $end
$var reg 5 G op_25_21 [4:0] $end
$var reg 5 H op_31_26 [4:0] $end
$var reg 6 I op_5_0 [5:0] $end
$var reg 1 J rst $end
$var integer 32 K i [31:0] $end
$scope module add_pc_shift $end
$var wire 32 L A [31:0] $end
$var wire 32 M ADDout [31:0] $end
$var wire 32 N temp [31:0] $end
$var wire 32 O B [31:0] $end
$upscope $end
$scope module adderTargetPC $end
$var wire 32 P sum_amount [31:0] $end
$var reg 32 Q receiver [31:0] $end
$upscope $end
$scope module alu $end
$var wire 1 B clk $end
$var wire 1 J rst $end
$var wire 32 R B [31:0] $end
$var wire 4 S ALUcontrol [3:0] $end
$var wire 32 T A [31:0] $end
$var reg 32 U ALUresult [31:0] $end
$var reg 33 V temp [32:0] $end
$var reg 1 5 zero $end
$upscope $end
$scope module alu_control $end
$var wire 1 B clk $end
$var wire 6 W op_5_0 [5:0] $end
$var wire 1 J rst $end
$var wire 2 X ALUOpcode [1:0] $end
$var reg 4 Y ALUControl [3:0] $end
$upscope $end
$scope module andControl $end
$var wire 1 5 B $end
$var wire 1 6 out $end
$var wire 1 = A $end
$upscope $end
$scope module control $end
$var wire 1 B clk $end
$var wire 1 J rst $end
$var wire 32 Z Opcode [31:0] $end
$var reg 2 [ ALUOpcode [1:0] $end
$var reg 1 > ALUSrc $end
$var reg 1 = Branch $end
$var reg 1 < Jump $end
$var reg 1 ; MemoryRead $end
$var reg 1 : MemoryToRegister $end
$var reg 1 9 MemoryWrite $end
$var reg 1 8 RegisterWrite $end
$var reg 1 7 RegistroDestino $end
$var reg 2 \ state [1:0] $end
$upscope $end
$scope module data_mem $end
$var wire 32 ] ALUResult [31:0] $end
$var wire 1 ; MemoryRead $end
$var wire 1 9 MemoryWrite $end
$var wire 1 B clk $end
$var wire 1 J rst $end
$var wire 32 ^ read_data [31:0] $end
$var reg 32 _ readDataMemory [31:0] $end
$upscope $end
$scope module inst_mem $end
$var wire 1 B clk $end
$var wire 8 ` pc [7:0] $end
$var wire 1 J rst $end
$var reg 32 a instruct [31:0] $end
$var integer 32 b i [31:0] $end
$upscope $end
$scope module join_shift_jump $end
$var wire 32 c Joined [31:0] $end
$var wire 4 d Last4 [3:0] $end
$var wire 28 e Shifted [27:0] $end
$upscope $end
$scope module muxALU $end
$var wire 1 > select $end
$var wire 32 f opt2 [31:0] $end
$var wire 32 g opt1 [31:0] $end
$var reg 32 h out [31:0] $end
$upscope $end
$scope module muxJump $end
$var wire 32 i opt1 [31:0] $end
$var wire 1 < select $end
$var wire 32 j opt2 [31:0] $end
$var reg 32 k out [31:0] $end
$upscope $end
$scope module muxWriteReg $end
$var wire 5 l opt1 [4:0] $end
$var wire 5 m opt2 [4:0] $end
$var wire 1 ! select $end
$var wire 5 n out [4:0] $end
$upscope $end
$scope module mux_32_pc $end
$var wire 32 o opt1 [31:0] $end
$var wire 32 p opt2 [31:0] $end
$var wire 1 " select $end
$var reg 32 q out [31:0] $end
$upscope $end
$scope module pc_module $end
$var wire 1 B clk $end
$var wire 32 r target_pc [31:0] $end
$var reg 32 s pc [31:0] $end
$upscope $end
$scope module register $end
$var wire 1 > ALUSrc $end
$var wire 1 = Branch $end
$var wire 1 : MemoryToRegister $end
$var wire 1 9 MemoryWrite $end
$var wire 1 8 RegisterWrite $end
$var wire 1 B clk $end
$var wire 5 t readRegister1 [4:0] $end
$var wire 5 u readRegister2 [4:0] $end
$var wire 1 J rst $end
$var wire 32 v writeBack [31:0] $end
$var wire 5 w writeRegister [4:0] $end
$var reg 32 x readData1 [31:0] $end
$var reg 32 y readData2 [31:0] $end
$var integer 32 z i [31:0] $end
$upscope $end
$scope module shiftLeftAdder $end
$var wire 32 { out [31:0] $end
$var wire 32 | in [31:0] $end
$upscope $end
$scope module shiftLeftJump $end
$var wire 32 } in [31:0] $end
$var wire 32 ~ out [31:0] $end
$upscope $end
$scope module sign_extend $end
$var wire 1 B clk $end
$var wire 16 !" in [15:0] $end
$var reg 32 "" out [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0xxxxxxxxxxxxxxxx ""
bx !"
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 ~
b0xxxxxxxxxxxxxxxxxxxxxxxxxx }
b0xxxxxxxxxxxxxxxx |
b0xxxxxxxxxxxxxxxx00 {
bx z
bx y
bx x
bx w
bx v
bz u
bz t
b0 s
bx r
bx q
bz p
bx o
bx n
bx m
bx l
bx k
bx j
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 i
b0xxxxxxxxxxxxxxxx h
bx g
b0xxxxxxxxxxxxxxxx f
bx00 e
bx d
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 c
bx b
bx a
b0 `
bx _
bx ^
bx ]
b0 \
b0 [
bx Z
bx Y
b0 X
bx W
bx V
bx U
bx T
bx S
b0xxxxxxxxxxxxxxxx R
bx Q
b100 P
b0xxxxxxxxxxxxxxxx00 O
bx N
bx M
bz L
b100000 K
xJ
bx I
bx H
bx G
bx F
bx E
bx D
bx C
0B
bx A
b0 @
bx ?
0>
0=
0<
0;
0:
09
08
07
06
x5
b0xxxxxxxxxxxxxxxx 4
bx 3
b0xxxxxxxxxxxxxxxx 2
bx 1
b0 0
bx /
bx .
bx -
bx ,
bx +
b0xxxxxxxxxxxxxxxx00 *
bx00 )
bx (
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 '
bz &
bz %
bz $
b100 #
z"
z!
$end
#1
b0x0000x00000000000x000010100 '
b0x0000x00000000000x000010100 c
b0x0000x00000000000x000010100 i
b100001000000000000000010100 )
b100001000000000000000010100 e
b100001000000000000000010100 ~
b0x000 1
b0x000 n
b0x000 w
b101 I
b101 W
b1000010000000000000000101 }
b1000010000000000000000101 F
b101 C
b101 !"
b0 D
b0 m
b1000 E
b1000 l
b1000 G
b1000 H
b10 d
b100001000010000000000000000101 3
b100001000010000000000000000101 Z
b100001000010000000000000000101 a
bx 0
bx `
bx s
b10 A
b10 S
b10 Y
b0xxxxxxxxxxxxxxxx 4
b0xxxxxxxxxxxxxxxx f
b0xxxxxxxxxxxxxxxx |
b0xxxxxxxxxxxxxxxx ""
1B
#2
1>
b10100 *
b10100 O
b10100 {
bx 2
bx R
bx h
b1 \
b101 4
b101 f
b101 |
b101 ""
0B
#3
bx00 )
bx00 e
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 ~
bx 1
bx n
bx w
bx I
bx W
b0xxxxxxxxxxxxxxxxxxxxxxxxxx }
bx F
bx C
bx !"
bx D
bx m
bx E
bx l
bx G
bx H
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 '
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 c
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 i
bx d
bx 3
bx Z
bx a
b101 2
b101 R
b101 h
0>
b0 \
b101 4
b101 f
b101 |
b101 ""
1B
#4
b0xxxxxxxxxxxxxxxx00 *
b0xxxxxxxxxxxxxxxx00 O
b0xxxxxxxxxxxxxxxx00 {
b0xxxxxxxxxxxxxxxx 2
b0xxxxxxxxxxxxxxxx R
b0xxxxxxxxxxxxxxxx h
b0xxxxxxxxxxxxxxxx 4
b0xxxxxxxxxxxxxxxx f
b0xxxxxxxxxxxxxxxx |
b0xxxxxxxxxxxxxxxx ""
0B
#5
b0xxxxxxxxxxxxxxxx 4
b0xxxxxxxxxxxxxxxx f
b0xxxxxxxxxxxxxxxx |
b0xxxxxxxxxxxxxxxx ""
1B
#6
b0xxxxxxxxxxxxxxxx 4
b0xxxxxxxxxxxxxxxx f
b0xxxxxxxxxxxxxxxx |
b0xxxxxxxxxxxxxxxx ""
0B
